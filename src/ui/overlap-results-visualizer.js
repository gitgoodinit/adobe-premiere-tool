/**
 * Overlap Results Visualizer
 * Provides visualization, playback, and export capabilities for overlap detection results
 */

class OverlapResultsVisualizer {
    constructor(containerElement, audioContext) {
        this.container = containerElement;
        this.audioContext = audioContext;
        
        // State
        this.overlapResults = [];
        this.audioTracks = new Map();
        this.currentPlayback = null;
        this.isPlaying = false;
        this.playbackGain = null;
        
        // Visualization settings
        this.waveformHeight = 80;
        this.waveformWidth = 800;
        this.timelineScale = 1; // pixels per second
        this.colors = {\n            track1: '#FF6B6B',\n            track2: '#4ECDC4',\n            overlap: '#FFE66D',\n            overlapHover: '#FFD93D',\n            waveform: '#666',\n            timeline: '#999'\n        };\n        \n        // DOM elements\n        this.elements = {\n            container: null,\n            timeline: null,\n            waveformCanvas: null,\n            overlapsList: null,\n            playbackControls: null,\n            exportControls: null\n        };\n        \n        this.initializeUI();\n        this.setupEventListeners();\n        \n        console.log('OverlapResultsVisualizer initialized');\n    }\n    \n    initializeUI() {\n        this.container.innerHTML = `\n            <div class=\"overlap-results-container\">\n                <!-- Header with stats -->\n                <div class=\"results-header\">\n                    <div class=\"results-stats\">\n                        <div class=\"stat-item\">\n                            <span class=\"stat-label\">Total Overlaps:</span>\n                            <span class=\"stat-value\" id=\"totalOverlaps\">0</span>\n                        </div>\n                        <div class=\"stat-item\">\n                            <span class=\"stat-label\">Duration:</span>\n                            <span class=\"stat-value\" id=\"totalDuration\">0.0s</span>\n                        </div>\n                        <div class=\"stat-item\">\n                            <span class=\"stat-label\">Avg Confidence:</span>\n                            <span class=\"stat-value\" id=\"avgConfidence\">0%</span>\n                        </div>\n                    </div>\n                    <div class=\"results-actions\">\n                        <button class=\"action-btn secondary\" id=\"exportResults\">\n                            <i class=\"fas fa-download\"></i> Export\n                        </button>\n                        <button class=\"action-btn secondary\" id=\"clearResults\">\n                            <i class=\"fas fa-trash\"></i> Clear\n                        </button>\n                    </div>\n                </div>\n                \n                <!-- Timeline Visualization -->\n                <div class=\"timeline-container\">\n                    <div class=\"timeline-header\">\n                        <h4><i class=\"fas fa-chart-line\"></i> Timeline Visualization</h4>\n                        <div class=\"timeline-controls\">\n                            <button class=\"mini-btn\" id=\"zoomIn\" title=\"Zoom In\">\n                                <i class=\"fas fa-search-plus\"></i>\n                            </button>\n                            <button class=\"mini-btn\" id=\"zoomOut\" title=\"Zoom Out\">\n                                <i class=\"fas fa-search-minus\"></i>\n                            </button>\n                            <button class=\"mini-btn\" id=\"fitToWindow\" title=\"Fit to Window\">\n                                <i class=\"fas fa-expand-arrows-alt\"></i>\n                            </button>\n                        </div>\n                    </div>\n                    \n                    <div class=\"timeline-wrapper\">\n                        <canvas id=\"timelineCanvas\" width=\"800\" height=\"200\"></canvas>\n                        <div class=\"playhead\" id=\"playhead\" style=\"display: none;\"></div>\n                    </div>\n                    \n                    <div class=\"timeline-scrubber\">\n                        <input type=\"range\" id=\"timelineScrubber\" min=\"0\" max=\"100\" value=\"0\" class=\"scrubber-slider\">\n                        <div class=\"time-display\">\n                            <span id=\"currentTime\">0:00</span>\n                            <span id=\"totalTime\">0:00</span>\n                        </div>\n                    </div>\n                </div>\n                \n                <!-- Playback Controls -->\n                <div class=\"playback-section\">\n                    <div class=\"playback-controls\">\n                        <button class=\"player-btn\" id=\"playAll\" title=\"Play All Overlaps\">\n                            <i class=\"fas fa-play\"></i>\n                        </button>\n                        <button class=\"player-btn\" id=\"pausePlayback\" title=\"Pause\" disabled>\n                            <i class=\"fas fa-pause\"></i>\n                        </button>\n                        <button class=\"player-btn\" id=\"stopPlayback\" title=\"Stop\" disabled>\n                            <i class=\"fas fa-stop\"></i>\n                        </button>\n                        <button class=\"player-btn\" id=\"playSelected\" title=\"Play Selected Overlap\" disabled>\n                            <i class=\"fas fa-play-circle\"></i>\n                        </button>\n                    </div>\n                    \n                    <div class=\"volume-section\">\n                        <i class=\"fas fa-volume-up\"></i>\n                        <input type=\"range\" id=\"volumeSlider\" min=\"0\" max=\"100\" value=\"50\" class=\"volume-slider\">\n                        <span id=\"volumeValue\">50%</span>\n                    </div>\n                </div>\n                \n                <!-- Results List -->\n                <div class=\"overlaps-list-section\">\n                    <div class=\"list-header\">\n                        <h4><i class=\"fas fa-list\"></i> Detected Overlaps</h4>\n                        <div class=\"list-filters\">\n                            <select id=\"typeFilter\" class=\"mini-select\">\n                                <option value=\"all\">All Types</option>\n                                <option value=\"speech-speech\">Speech-Speech</option>\n                                <option value=\"speech-music\">Speech-Music</option>\n                                <option value=\"music-music\">Music-Music</option>\n                                <option value=\"mixed\">Mixed</option>\n                            </select>\n                            <select id=\"sortBy\" class=\"mini-select\">\n                                <option value=\"time\">Sort by Time</option>\n                                <option value=\"duration\">Sort by Duration</option>\n                                <option value=\"confidence\">Sort by Confidence</option>\n                            </select>\n                        </div>\n                    </div>\n                    \n                    <div class=\"overlaps-list\" id=\"overlapsList\">\n                        <div class=\"empty-state\">\n                            <i class=\"fas fa-wave-square\"></i>\n                            <p>No overlaps detected yet. Run overlap detection to see results.</p>\n                        </div>\n                    </div>\n                </div>\n                \n                <!-- Export Modal -->\n                <div class=\"modal\" id=\"exportModal\" style=\"display: none;\">\n                    <div class=\"modal-content\">\n                        <div class=\"modal-header\">\n                            <h3>Export Overlap Results</h3>\n                            <button class=\"modal-close\" id=\"closeExportModal\">\n                                <i class=\"fas fa-times\"></i>\n                            </button>\n                        </div>\n                        \n                        <div class=\"modal-body\">\n                            <div class=\"export-format\">\n                                <label>Export Format:</label>\n                                <div class=\"format-options\">\n                                    <label class=\"radio-option\">\n                                        <input type=\"radio\" name=\"exportFormat\" value=\"json\" checked>\n                                        <span class=\"radio-mark\"></span>\n                                        JSON (Detailed)\n                                    </label>\n                                    <label class=\"radio-option\">\n                                        <input type=\"radio\" name=\"exportFormat\" value=\"csv\">\n                                        <span class=\"radio-mark\"></span>\n                                        CSV (Spreadsheet)\n                                    </label>\n                                    <label class=\"radio-option\">\n                                        <input type=\"radio\" name=\"exportFormat\" value=\"xml\">\n                                        <span class=\"radio-mark\"></span>\n                                        XML (Structured)\n                                    </label>\n                                </div>\n                            </div>\n                            \n                            <div class=\"export-options\">\n                                <label class=\"checkbox-option\">\n                                    <input type=\"checkbox\" id=\"includeMetadata\" checked>\n                                    <span class=\"checkmark\"></span>\n                                    Include Analysis Metadata\n                                </label>\n                                <label class=\"checkbox-option\">\n                                    <input type=\"checkbox\" id=\"includeAudioSegments\">\n                                    <span class=\"checkmark\"></span>\n                                    Export Audio Segments (WAV)\n                                </label>\n                            </div>\n                        </div>\n                        \n                        <div class=\"modal-footer\">\n                            <button class=\"action-btn secondary\" id=\"cancelExport\">\n                                Cancel\n                            </button>\n                            <button class=\"action-btn primary\" id=\"confirmExport\">\n                                <i class=\"fas fa-download\"></i> Export\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `;\n        \n        // Cache DOM elements\n        this.elements.container = this.container.querySelector('.overlap-results-container');\n        this.elements.timeline = this.container.querySelector('#timelineCanvas');\n        this.elements.overlapsList = this.container.querySelector('#overlapsList');\n        this.elements.playbackControls = this.container.querySelector('.playback-controls');\n        this.elements.exportControls = this.container.querySelector('.results-actions');\n        \n        // Initialize audio for playback\n        this.initializeAudio();\n    }\n    \n    initializeAudio() {\n        try {\n            // Create master gain node for volume control\n            this.playbackGain = this.audioContext.createGain();\n            this.playbackGain.gain.value = 0.5; // 50% initial volume\n            this.playbackGain.connect(this.audioContext.destination);\n            \n            console.log('Audio playback initialized');\n        } catch (error) {\n            console.error('Failed to initialize audio:', error);\n        }\n    }\n    \n    setupEventListeners() {\n        // Timeline controls\n        this.container.querySelector('#zoomIn').addEventListener('click', () => this.zoomTimeline(1.5));\n        this.container.querySelector('#zoomOut').addEventListener('click', () => this.zoomTimeline(0.75));\n        this.container.querySelector('#fitToWindow').addEventListener('click', () => this.fitTimelineToWindow());\n        \n        // Playback controls\n        this.container.querySelector('#playAll').addEventListener('click', () => this.playAllOverlaps());\n        this.container.querySelector('#pausePlayback').addEventListener('click', () => this.pausePlayback());\n        this.container.querySelector('#stopPlayback').addEventListener('click', () => this.stopPlayback());\n        this.container.querySelector('#playSelected').addEventListener('click', () => this.playSelectedOverlap());\n        \n        // Volume control\n        const volumeSlider = this.container.querySelector('#volumeSlider');\n        volumeSlider.addEventListener('input', (e) => {\n            const volume = e.target.value / 100;\n            this.setVolume(volume);\n            this.container.querySelector('#volumeValue').textContent = `${e.target.value}%`;\n        });\n        \n        // Timeline scrubber\n        const scrubber = this.container.querySelector('#timelineScrubber');\n        scrubber.addEventListener('input', (e) => this.scrubToPosition(e.target.value / 100));\n        \n        // Filters and sorting\n        this.container.querySelector('#typeFilter').addEventListener('change', () => this.filterOverlaps());\n        this.container.querySelector('#sortBy').addEventListener('change', () => this.sortOverlaps());\n        \n        // Export controls\n        this.container.querySelector('#exportResults').addEventListener('click', () => this.showExportModal());\n        this.container.querySelector('#clearResults').addEventListener('click', () => this.clearResults());\n        \n        // Export modal\n        this.container.querySelector('#closeExportModal').addEventListener('click', () => this.hideExportModal());\n        this.container.querySelector('#cancelExport').addEventListener('click', () => this.hideExportModal());\n        this.container.querySelector('#confirmExport').addEventListener('click', () => this.exportResults());\n        \n        // Timeline canvas interactions\n        const canvas = this.elements.timeline;\n        canvas.addEventListener('click', (e) => this.onTimelineClick(e));\n        canvas.addEventListener('mousemove', (e) => this.onTimelineHover(e));\n        canvas.addEventListener('mouseleave', () => this.clearTimelineHover());\n    }\n    \n    // Data management\n    displayResults(overlapResults, audioTracks) {\n        this.overlapResults = overlapResults || [];\n        this.audioTracks = audioTracks || new Map();\n        \n        this.updateStats();\n        this.renderTimeline();\n        this.renderOverlapsList();\n        \n        console.log(`Displaying ${this.overlapResults.length} overlap results`);\n    }\n    \n    updateStats() {\n        const totalOverlaps = this.overlapResults.length;\n        const totalDuration = this.overlapResults.reduce((sum, overlap) => sum + overlap.duration, 0);\n        const avgConfidence = totalOverlaps > 0 ? \n            this.overlapResults.reduce((sum, overlap) => sum + overlap.confidence, 0) / totalOverlaps : 0;\n        \n        this.container.querySelector('#totalOverlaps').textContent = totalOverlaps;\n        this.container.querySelector('#totalDuration').textContent = `${totalDuration.toFixed(1)}s`;\n        this.container.querySelector('#avgConfidence').textContent = `${Math.round(avgConfidence * 100)}%`;\n    }\n    \n    renderTimeline() {\n        const canvas = this.elements.timeline;\n        const ctx = canvas.getContext('2d');\n        \n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        if (this.overlapResults.length === 0) {\n            this.drawEmptyTimeline(ctx);\n            return;\n        }\n        \n        // Calculate timeline bounds\n        const maxTime = Math.max(...this.overlapResults.map(overlap => overlap.endTime));\n        this.timelineScale = canvas.width / maxTime;\n        \n        // Draw timeline background\n        this.drawTimelineBackground(ctx, maxTime);\n        \n        // Draw track waveforms (if available)\n        this.drawWaveforms(ctx);\n        \n        // Draw overlap regions\n        this.drawOverlapRegions(ctx);\n        \n        // Draw time markers\n        this.drawTimeMarkers(ctx, maxTime);\n        \n        // Update scrubber\n        this.updateScrubber(maxTime);\n    }\n    \n    drawEmptyTimeline(ctx) {\n        ctx.fillStyle = '#f5f5f5';\n        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n        \n        ctx.fillStyle = '#999';\n        ctx.font = '16px Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText('No overlaps to display', ctx.canvas.width / 2, ctx.canvas.height / 2);\n    }\n    \n    drawTimelineBackground(ctx, maxTime) {\n        // Background\n        ctx.fillStyle = '#fafafa';\n        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n        \n        // Grid lines\n        ctx.strokeStyle = '#e0e0e0';\n        ctx.lineWidth = 1;\n        \n        const gridInterval = this.calculateGridInterval(maxTime);\n        for (let time = 0; time <= maxTime; time += gridInterval) {\n            const x = time * this.timelineScale;\n            ctx.beginPath();\n            ctx.moveTo(x, 0);\n            ctx.lineTo(x, ctx.canvas.height);\n            ctx.stroke();\n        }\n    }\n    \n    drawWaveforms(ctx) {\n        const trackHeight = 40;\n        let yOffset = 20;\n        \n        this.audioTracks.forEach((trackData, trackId) => {\n            if (!trackData.buffer) return;\n            \n            const channelData = trackData.buffer.getChannelData(0);\n            const samplesPerPixel = channelData.length / ctx.canvas.width;\n            \n            ctx.strokeStyle = trackData.color || this.colors.waveform;\n            ctx.lineWidth = 1;\n            ctx.globalAlpha = 0.3;\n            \n            ctx.beginPath();\n            for (let x = 0; x < ctx.canvas.width; x++) {\n                const sampleIndex = Math.floor(x * samplesPerPixel);\n                const sample = channelData[sampleIndex] || 0;\n                const y = yOffset + trackHeight / 2 + sample * trackHeight / 2;\n                \n                if (x === 0) {\n                    ctx.moveTo(x, y);\n                } else {\n                    ctx.lineTo(x, y);\n                }\n            }\n            ctx.stroke();\n            \n            // Track label\n            ctx.globalAlpha = 1;\n            ctx.fillStyle = '#666';\n            ctx.font = '12px Arial';\n            ctx.textAlign = 'left';\n            ctx.fillText(trackData.name || `Track ${trackId}`, 5, yOffset + 15);\n            \n            yOffset += trackHeight + 10;\n        });\n    }\n    \n    drawOverlapRegions(ctx) {\n        ctx.globalAlpha = 0.7;\n        \n        this.overlapResults.forEach((overlap, index) => {\n            const x = overlap.startTime * this.timelineScale;\n            const width = overlap.duration * this.timelineScale;\n            const height = ctx.canvas.height - 40;\n            \n            // Color based on confidence\n            const confidence = overlap.confidence;\n            const intensity = Math.floor(255 * (1 - confidence));\n            ctx.fillStyle = `rgba(255, ${intensity}, ${intensity}, 0.6)`;\n            \n            ctx.fillRect(x, 20, width, height);\n            \n            // Border\n            ctx.strokeStyle = this.colors.overlap;\n            ctx.lineWidth = 2;\n            ctx.strokeRect(x, 20, width, height);\n            \n            // Label\n            if (width > 30) {\n                ctx.fillStyle = '#333';\n                ctx.font = '10px Arial';\n                ctx.textAlign = 'center';\n                ctx.fillText(\n                    `${overlap.id}\\n${overlap.confidence.toFixed(2)}`,\n                    x + width / 2,\n                    30\n                );\n            }\n        });\n        \n        ctx.globalAlpha = 1;\n    }\n    \n    drawTimeMarkers(ctx, maxTime) {\n        const markerInterval = this.calculateGridInterval(maxTime);\n        \n        ctx.fillStyle = '#666';\n        ctx.font = '11px Arial';\n        ctx.textAlign = 'center';\n        \n        for (let time = 0; time <= maxTime; time += markerInterval) {\n            const x = time * this.timelineScale;\n            const timeLabel = this.formatTime(time);\n            \n            ctx.fillText(timeLabel, x, ctx.canvas.height - 5);\n        }\n    }\n    \n    renderOverlapsList() {\n        const container = this.elements.overlapsList;\n        \n        if (this.overlapResults.length === 0) {\n            container.innerHTML = `\n                <div class=\"empty-state\">\n                    <i class=\"fas fa-wave-square\"></i>\n                    <p>No overlaps detected yet. Run overlap detection to see results.</p>\n                </div>\n            `;\n            return;\n        }\n        \n        const html = this.overlapResults.map((overlap, index) => `\n            <div class=\"overlap-item\" data-overlap-id=\"${overlap.id}\" data-index=\"${index}\">\n                <div class=\"overlap-header\">\n                    <div class=\"overlap-id\">\n                        <span class=\"id-badge\">${overlap.id}</span>\n                        <span class=\"type-badge type-${overlap.type}\">${overlap.type}</span>\n                    </div>\n                    <div class=\"overlap-actions\">\n                        <button class=\"mini-btn play-overlap\" title=\"Play this overlap\">\n                            <i class=\"fas fa-play\"></i>\n                        </button>\n                        <button class=\"mini-btn export-overlap\" title=\"Export this overlap\">\n                            <i class=\"fas fa-download\"></i>\n                        </button>\n                    </div>\n                </div>\n                \n                <div class=\"overlap-details\">\n                    <div class=\"detail-row\">\n                        <span class=\"detail-label\">Tracks:</span>\n                        <span class=\"detail-value\">\n                            ${overlap.metadata.track1Name} ↔ ${overlap.metadata.track2Name}\n                        </span>\n                    </div>\n                    <div class=\"detail-row\">\n                        <span class=\"detail-label\">Time:</span>\n                        <span class=\"detail-value\">\n                            ${this.formatTime(overlap.startTime)} - ${this.formatTime(overlap.endTime)}\n                            <span class=\"duration\">(${overlap.duration.toFixed(2)}s)</span>\n                        </span>\n                    </div>\n                    <div class=\"detail-row\">\n                        <span class=\"detail-label\">Confidence:</span>\n                        <span class=\"detail-value\">\n                            <div class=\"confidence-bar\">\n                                <div class=\"confidence-fill\" style=\"width: ${overlap.confidence * 100}%\"></div>\n                            </div>\n                            <span class=\"confidence-text\">${Math.round(overlap.confidence * 100)}%</span>\n                        </span>\n                    </div>\n                </div>\n                \n                <div class=\"overlap-metrics\">\n                    <div class=\"metric\">\n                        <span class=\"metric-label\">Cross-Correlation:</span>\n                        <span class=\"metric-value\">${overlap.details.crossCorrelation.toFixed(3)}</span>\n                    </div>\n                    <div class=\"metric\">\n                        <span class=\"metric-label\">Spectral Similarity:</span>\n                        <span class=\"metric-value\">${overlap.details.spectralSimilarity.toFixed(3)}</span>\n                    </div>\n                    <div class=\"metric\">\n                        <span class=\"metric-label\">Temporal Similarity:</span>\n                        <span class=\"metric-value\">${overlap.details.temporalSimilarity.toFixed(3)}</span>\n                    </div>\n                </div>\n            </div>\n        `).join('');\n        \n        container.innerHTML = html;\n        \n        // Add event listeners to overlap items\n        container.querySelectorAll('.overlap-item').forEach((item, index) => {\n            item.addEventListener('click', () => this.selectOverlap(index));\n            \n            item.querySelector('.play-overlap').addEventListener('click', (e) => {\n                e.stopPropagation();\n                this.playOverlap(index);\n            });\n            \n            item.querySelector('.export-overlap').addEventListener('click', (e) => {\n                e.stopPropagation();\n                this.exportSingleOverlap(index);\n            });\n        });\n    }\n    \n    // Playback functionality\n    async playAllOverlaps() {\n        if (this.overlapResults.length === 0) return;\n        \n        console.log('Playing all overlaps...');\n        this.setPlaybackState(true);\n        \n        for (let i = 0; i < this.overlapResults.length; i++) {\n            if (!this.isPlaying) break;\n            \n            await this.playOverlap(i, false);\n            \n            // Brief pause between overlaps\n            if (this.isPlaying && i < this.overlapResults.length - 1) {\n                await this.delay(500);\n            }\n        }\n        \n        this.setPlaybackState(false);\n    }\n    \n    async playOverlap(index, standalone = true) {\n        const overlap = this.overlapResults[index];\n        if (!overlap) return;\n        \n        if (standalone) {\n            this.setPlaybackState(true);\n        }\n        \n        try {\n            // Get audio tracks\n            const track1 = this.audioTracks.get(overlap.track1);\n            const track2 = this.audioTracks.get(overlap.track2);\n            \n            if (!track1?.buffer || !track2?.buffer) {\n                console.warn('Audio buffers not available for playback');\n                return;\n            }\n            \n            // Create audio sources for the overlap region\n            const source1 = this.audioContext.createBufferSource();\n            const source2 = this.audioContext.createBufferSource();\n            \n            source1.buffer = track1.buffer;\n            source2.buffer = track2.buffer;\n            \n            // Create gain nodes for mixing\n            const gain1 = this.audioContext.createGain();\n            const gain2 = this.audioContext.createGain();\n            \n            gain1.gain.value = 0.5;\n            gain2.gain.value = 0.5;\n            \n            // Connect audio graph\n            source1.connect(gain1);\n            source2.connect(gain2);\n            gain1.connect(this.playbackGain);\n            gain2.connect(this.playbackGain);\n            \n            // Start playback at overlap time\n            const currentTime = this.audioContext.currentTime;\n            source1.start(currentTime, overlap.startTime, overlap.duration);\n            source2.start(currentTime, overlap.startTime, overlap.duration);\n            \n            // Highlight playing overlap\n            this.highlightOverlap(index);\n            \n            // Stop after duration\n            return new Promise(resolve => {\n                setTimeout(() => {\n                    source1.stop();\n                    source2.stop();\n                    this.unhighlightOverlap(index);\n                    \n                    if (standalone) {\n                        this.setPlaybackState(false);\n                    }\n                    \n                    resolve();\n                }, overlap.duration * 1000);\n            });\n            \n        } catch (error) {\n            console.error('Playback error:', error);\n            if (standalone) {\n                this.setPlaybackState(false);\n            }\n        }\n    }\n    \n    pausePlayback() {\n        // Note: Web Audio API doesn't support pause/resume easily\n        // For a full implementation, you'd need to track playback state\n        this.stopPlayback();\n    }\n    \n    stopPlayback() {\n        this.setPlaybackState(false);\n        this.unhighlightAllOverlaps();\n        console.log('Playback stopped');\n    }\n    \n    setVolume(volume) {\n        if (this.playbackGain) {\n            this.playbackGain.gain.value = volume;\n        }\n    }\n    \n    // UI interaction\n    selectOverlap(index) {\n        // Deselect all\n        this.container.querySelectorAll('.overlap-item').forEach(item => {\n            item.classList.remove('selected');\n        });\n        \n        // Select clicked item\n        const item = this.container.querySelector(`[data-index=\"${index}\"]`);\n        if (item) {\n            item.classList.add('selected');\n            this.selectedOverlapIndex = index;\n            this.container.querySelector('#playSelected').disabled = false;\n        }\n    }\n    \n    highlightOverlap(index) {\n        const item = this.container.querySelector(`[data-index=\"${index}\"]`);\n        if (item) {\n            item.classList.add('playing');\n        }\n    }\n    \n    unhighlightOverlap(index) {\n        const item = this.container.querySelector(`[data-index=\"${index}\"]`);\n        if (item) {\n            item.classList.remove('playing');\n        }\n    }\n    \n    unhighlightAllOverlaps() {\n        this.container.querySelectorAll('.overlap-item').forEach(item => {\n            item.classList.remove('playing');\n        });\n    }\n    \n    setPlaybackState(isPlaying) {\n        this.isPlaying = isPlaying;\n        \n        const playBtn = this.container.querySelector('#playAll');\n        const pauseBtn = this.container.querySelector('#pausePlayback');\n        const stopBtn = this.container.querySelector('#stopPlayback');\n        \n        playBtn.disabled = isPlaying;\n        pauseBtn.disabled = !isPlaying;\n        stopBtn.disabled = !isPlaying;\n        \n        if (isPlaying) {\n            playBtn.innerHTML = '<i class=\"fas fa-spinner fa-spin\"></i>';\n        } else {\n            playBtn.innerHTML = '<i class=\"fas fa-play\"></i>';\n        }\n    }\n    \n    // Timeline interactions\n    onTimelineClick(e) {\n        const rect = this.elements.timeline.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const time = x / this.timelineScale;\n        \n        // Find overlap at clicked time\n        const overlap = this.overlapResults.find(o => \n            time >= o.startTime && time <= o.endTime\n        );\n        \n        if (overlap) {\n            const index = this.overlapResults.indexOf(overlap);\n            this.selectOverlap(index);\n            this.playOverlap(index);\n        }\n    }\n    \n    onTimelineHover(e) {\n        // Show tooltip with overlap info\n        const rect = this.elements.timeline.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const time = x / this.timelineScale;\n        \n        const overlap = this.overlapResults.find(o => \n            time >= o.startTime && time <= o.endTime\n        );\n        \n        if (overlap) {\n            this.showTimelineTooltip(e.clientX, e.clientY, overlap);\n        } else {\n            this.hideTimelineTooltip();\n        }\n    }\n    \n    showTimelineTooltip(x, y, overlap) {\n        // Implementation for timeline tooltip\n        console.log('Show tooltip for overlap:', overlap.id);\n    }\n    \n    hideTimelineTooltip() {\n        // Implementation for hiding tooltip\n    }\n    \n    clearTimelineHover() {\n        this.hideTimelineTooltip();\n    }\n    \n    // Export functionality\n    showExportModal() {\n        this.container.querySelector('#exportModal').style.display = 'flex';\n    }\n    \n    hideExportModal() {\n        this.container.querySelector('#exportModal').style.display = 'none';\n    }\n    \n    async exportResults() {\n        const format = this.container.querySelector('input[name=\"exportFormat\"]:checked').value;\n        const includeMetadata = this.container.querySelector('#includeMetadata').checked;\n        const includeAudioSegments = this.container.querySelector('#includeAudioSegments').checked;\n        \n        try {\n            let exportData;\n            let filename;\n            let mimeType;\n            \n            // Create export data based on format\n            switch (format) {\n                case 'json':\n                    exportData = this.createJSONExport(includeMetadata);\n                    filename = `overlap-results-${Date.now()}.json`;\n                    mimeType = 'application/json';\n                    break;\n                    \n                case 'csv':\n                    exportData = this.createCSVExport();\n                    filename = `overlap-results-${Date.now()}.csv`;\n                    mimeType = 'text/csv';\n                    break;\n                    \n                case 'xml':\n                    exportData = this.createXMLExport(includeMetadata);\n                    filename = `overlap-results-${Date.now()}.xml`;\n                    mimeType = 'application/xml';\n                    break;\n            }\n            \n            // Download file\n            this.downloadFile(exportData, filename, mimeType);\n            \n            // Export audio segments if requested\n            if (includeAudioSegments) {\n                await this.exportAudioSegments();\n            }\n            \n            this.hideExportModal();\n            \n            console.log(`Exported ${this.overlapResults.length} overlaps as ${format}`);\n            \n        } catch (error) {\n            console.error('Export failed:', error);\n            alert('Export failed: ' + error.message);\n        }\n    }\n    \n    createJSONExport(includeMetadata) {\n        const exportData = {\n            metadata: {\n                timestamp: new Date().toISOString(),\n                totalOverlaps: this.overlapResults.length,\n                exportFormat: 'json'\n            },\n            overlaps: this.overlapResults\n        };\n        \n        if (!includeMetadata) {\n            delete exportData.metadata;\n        }\n        \n        return JSON.stringify(exportData, null, 2);\n    }\n    \n    createCSVExport() {\n        const headers = [\n            'ID', 'Track1', 'Track2', 'Track1Name', 'Track2Name',\n            'StartTime', 'EndTime', 'Duration', 'Type', 'Confidence',\n            'CrossCorrelation', 'SpectralSimilarity', 'TemporalSimilarity'\n        ];\n        \n        const rows = this.overlapResults.map(overlap => [\n            overlap.id,\n            overlap.track1,\n            overlap.track2,\n            overlap.metadata.track1Name,\n            overlap.metadata.track2Name,\n            overlap.startTime.toFixed(3),\n            overlap.endTime.toFixed(3),\n            overlap.duration.toFixed(3),\n            overlap.type,\n            overlap.confidence.toFixed(3),\n            overlap.details.crossCorrelation.toFixed(3),\n            overlap.details.spectralSimilarity.toFixed(3),\n            overlap.details.temporalSimilarity.toFixed(3)\n        ]);\n        \n        return [headers, ...rows].map(row => row.join(',')).join('\\n');\n    }\n    \n    createXMLExport(includeMetadata) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<overlapAnalysis>\\n';\n        \n        if (includeMetadata) {\n            xml += '  <metadata>\\n';\n            xml += `    <timestamp>${new Date().toISOString()}</timestamp>\\n`;\n            xml += `    <totalOverlaps>${this.overlapResults.length}</totalOverlaps>\\n`;\n            xml += '  </metadata>\\n';\n        }\n        \n        xml += '  <overlaps>\\n';\n        this.overlapResults.forEach(overlap => {\n            xml += `    <overlap id=\"${overlap.id}\">\\n`;\n            xml += `      <tracks track1=\"${overlap.track1}\" track2=\"${overlap.track2}\" />\\n`;\n            xml += `      <timing start=\"${overlap.startTime}\" end=\"${overlap.endTime}\" duration=\"${overlap.duration}\" />\\n`;\n            xml += `      <classification type=\"${overlap.type}\" confidence=\"${overlap.confidence}\" />\\n`;\n            xml += `      <metrics>\\n`;\n            xml += `        <crossCorrelation>${overlap.details.crossCorrelation}</crossCorrelation>\\n`;\n            xml += `        <spectralSimilarity>${overlap.details.spectralSimilarity}</spectralSimilarity>\\n`;\n            xml += `        <temporalSimilarity>${overlap.details.temporalSimilarity}</temporalSimilarity>\\n`;\n            xml += `      </metrics>\\n`;\n            xml += `    </overlap>\\n`;\n        });\n        xml += '  </overlaps>\\n';\n        xml += '</overlapAnalysis>';\n        \n        return xml;\n    }\n    \n    async exportAudioSegments() {\n        for (let i = 0; i < this.overlapResults.length; i++) {\n            const overlap = this.overlapResults[i];\n            \n            try {\n                const audioBlob = await this.createOverlapAudioBlob(overlap);\n                const filename = `overlap-${overlap.id}-${Date.now()}.wav`;\n                \n                this.downloadFile(audioBlob, filename, 'audio/wav');\n                \n            } catch (error) {\n                console.error(`Failed to export audio for overlap ${overlap.id}:`, error);\n            }\n        }\n    }\n    \n    async createOverlapAudioBlob(overlap) {\n        // Get audio tracks\n        const track1 = this.audioTracks.get(overlap.track1);\n        const track2 = this.audioTracks.get(overlap.track2);\n        \n        if (!track1?.buffer || !track2?.buffer) {\n            throw new Error('Audio buffers not available');\n        }\n        \n        // Create a new audio buffer for the overlap segment\n        const startSample = Math.floor(overlap.startTime * track1.buffer.sampleRate);\n        const lengthSamples = Math.floor(overlap.duration * track1.buffer.sampleRate);\n        \n        const mixedBuffer = this.audioContext.createBuffer(\n            2, // stereo\n            lengthSamples,\n            track1.buffer.sampleRate\n        );\n        \n        // Mix tracks (track1 -> left, track2 -> right)\n        const leftChannel = mixedBuffer.getChannelData(0);\n        const rightChannel = mixedBuffer.getChannelData(1);\n        \n        const track1Data = track1.buffer.getChannelData(0);\n        const track2Data = track2.buffer.getChannelData(0);\n        \n        for (let i = 0; i < lengthSamples; i++) {\n            const sampleIndex = startSample + i;\n            leftChannel[i] = track1Data[sampleIndex] || 0;\n            rightChannel[i] = track2Data[sampleIndex] || 0;\n        }\n        \n        // Convert to WAV blob\n        return this.audioBufferToWavBlob(mixedBuffer);\n    }\n    \n    audioBufferToWavBlob(buffer) {\n        const length = buffer.length * buffer.numberOfChannels * 2;\n        const arrayBuffer = new ArrayBuffer(44 + length);\n        const view = new DataView(arrayBuffer);\n        \n        // WAV header\n        const writeString = (offset, string) => {\n            for (let i = 0; i < string.length; i++) {\n                view.setUint8(offset + i, string.charCodeAt(i));\n            }\n        };\n        \n        writeString(0, 'RIFF');\n        view.setUint32(4, 36 + length, true);\n        writeString(8, 'WAVE');\n        writeString(12, 'fmt ');\n        view.setUint32(16, 16, true);\n        view.setUint16(20, 1, true);\n        view.setUint16(22, buffer.numberOfChannels, true);\n        view.setUint32(24, buffer.sampleRate, true);\n        view.setUint32(28, buffer.sampleRate * buffer.numberOfChannels * 2, true);\n        view.setUint16(32, buffer.numberOfChannels * 2, true);\n        view.setUint16(34, 16, true);\n        writeString(36, 'data');\n        view.setUint32(40, length, true);\n        \n        // Audio data\n        let offset = 44;\n        for (let i = 0; i < buffer.length; i++) {\n            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n                const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));\n                view.setInt16(offset, sample * 0x7FFF, true);\n                offset += 2;\n            }\n        }\n        \n        return new Blob([arrayBuffer], { type: 'audio/wav' });\n    }\n    \n    downloadFile(content, filename, mimeType) {\n        const blob = content instanceof Blob ? content : new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        \n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        \n        URL.revokeObjectURL(url);\n    }\n    \n    exportSingleOverlap(index) {\n        const overlap = this.overlapResults[index];\n        if (!overlap) return;\n        \n        const exportData = {\n            overlap: overlap,\n            metadata: {\n                timestamp: new Date().toISOString(),\n                exportType: 'single-overlap'\n            }\n        };\n        \n        const filename = `overlap-${overlap.id}-${Date.now()}.json`;\n        this.downloadFile(JSON.stringify(exportData, null, 2), filename, 'application/json');\n    }\n    \n    // Filtering and sorting\n    filterOverlaps() {\n        const filterValue = this.container.querySelector('#typeFilter').value;\n        const items = this.container.querySelectorAll('.overlap-item');\n        \n        items.forEach((item, index) => {\n            const overlap = this.overlapResults[index];\n            const shouldShow = filterValue === 'all' || overlap.type === filterValue;\n            item.style.display = shouldShow ? 'block' : 'none';\n        });\n    }\n    \n    sortOverlaps() {\n        const sortValue = this.container.querySelector('#sortBy').value;\n        \n        const sortedResults = [...this.overlapResults];\n        \n        switch (sortValue) {\n            case 'time':\n                sortedResults.sort((a, b) => a.startTime - b.startTime);\n                break;\n            case 'duration':\n                sortedResults.sort((a, b) => b.duration - a.duration);\n                break;\n            case 'confidence':\n                sortedResults.sort((a, b) => b.confidence - a.confidence);\n                break;\n        }\n        \n        this.overlapResults = sortedResults;\n        this.renderOverlapsList();\n        this.renderTimeline();\n    }\n    \n    // Utility functions\n    formatTime(seconds) {\n        const mins = Math.floor(seconds / 60);\n        const secs = (seconds % 60).toFixed(1);\n        return `${mins}:${secs.padStart(4, '0')}`;\n    }\n    \n    calculateGridInterval(maxTime) {\n        if (maxTime <= 10) return 1;\n        if (maxTime <= 60) return 5;\n        if (maxTime <= 300) return 30;\n        return 60;\n    }\n    \n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    \n    zoomTimeline(factor) {\n        this.timelineScale *= factor;\n        this.renderTimeline();\n    }\n    \n    fitTimelineToWindow() {\n        if (this.overlapResults.length === 0) return;\n        \n        const maxTime = Math.max(...this.overlapResults.map(overlap => overlap.endTime));\n        this.timelineScale = this.elements.timeline.width / maxTime;\n        this.renderTimeline();\n    }\n    \n    scrubToPosition(position) {\n        // Implementation for scrubbing to specific position\n        console.log('Scrub to position:', position);\n    }\n    \n    updateScrubber(maxTime) {\n        const scrubber = this.container.querySelector('#timelineScrubber');\n        scrubber.max = maxTime.toFixed(1);\n        \n        this.container.querySelector('#totalTime').textContent = this.formatTime(maxTime);\n    }\n    \n    playSelectedOverlap() {\n        if (typeof this.selectedOverlapIndex !== 'undefined') {\n            this.playOverlap(this.selectedOverlapIndex);\n        }\n    }\n    \n    clearResults() {\n        this.overlapResults = [];\n        this.audioTracks.clear();\n        this.selectedOverlapIndex = undefined;\n        \n        this.updateStats();\n        this.renderTimeline();\n        this.renderOverlapsList();\n        \n        console.log('Results cleared');\n    }\n    \n    // Cleanup\n    destroy() {\n        this.stopPlayback();\n        \n        if (this.playbackGain) {\n            this.playbackGain.disconnect();\n            this.playbackGain = null;\n        }\n        \n        this.container.innerHTML = '';\n        console.log('OverlapResultsVisualizer destroyed');\n    }\n}\n\nexport default OverlapResultsVisualizer;"
